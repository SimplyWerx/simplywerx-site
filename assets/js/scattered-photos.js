/**
 * Scattered Photos Background Effect
 * Creates a dynamic scattered photo collage background
 */

(function() {
    'use strict';

    // Adjust photo sizes for mobile
    const isMobile = window.innerWidth <= 768;
        
    // Configuration
    const config = {
        minSize: isMobile ? 90 : 160,   // Minimum photo size in pixels
        maxSize: isMobile ? 180 : 320,   // Maximum photo size in pixels
        parallaxEffect: true // Enable subtle parallax on scroll
    };

    // Photo list is loaded from photo-list.js (auto-generated by Jekyll)
    const photoList = typeof PHOTO_LIST !== 'undefined' ? PHOTO_LIST : [];

    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function getRandomPhotos(count) {
        const shuffled = [...photoList].sort(() => 0.5 - Math.random());
        return shuffled.slice(0, Math.min(count, photoList.length));
    }

    function createScatteredPhotos() {
        const header = document.querySelector('header.masthead');
        if (!header) return;

        // Create container for scattered photos
        let container = document.querySelector('.scattered-photos-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'scattered-photos-container';
            header.insertBefore(container, header.firstChild);
        }

        // Clear existing photos
        container.innerHTML = '';

        // Calculate grid based on mean photo size
        const meanSize = (config.minSize + config.maxSize) / 2;
        const headerWidth = header.offsetWidth;
        const headerHeight = header.offsetHeight;
        
        // Calculate how many photos can fit in the grid (with some overlap/spacing factor)
        const spacingFactor = 0.7; // Photos can overlap, so we use less space per photo
        const cols = Math.max(3, Math.floor(headerWidth / (meanSize * spacingFactor)));
        const rows = Math.max(3, Math.floor(headerHeight / (meanSize * spacingFactor)));
        const photoCount = cols * rows;
        
        const selectedPhotos = getRandomPhotos(photoCount);
        const actualPhotoCount = selectedPhotos.length;
        const cellWidth = headerWidth / cols;
        const cellHeight = headerHeight / rows;
        
        // Create randomized grid positions
        const totalGridCells = cols * rows;
        const gridPositions = Array.from({length: totalGridCells}, (_, i) => i);
        // Shuffle the grid positions
        for (let i = gridPositions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];
        }
        
        selectedPhotos.forEach((photo, index) => {
            const photoElement = document.createElement('div');
            photoElement.className = 'scattered-photo';
            
            const size = getRandomInt(config.minSize, config.maxSize);
            const rotation = getRandomInt(-25, 25);
            
            // Calculate grid position using randomized sequence
            const gridIndex = gridPositions[index] % totalGridCells;
            const gridCol = gridIndex % cols;
            const gridRow = Math.floor(gridIndex / cols);
            
            // Position within grid cell with randomness for natural look
            // Start from the beginning of each grid cell and randomize position within it
            const basLeft = gridCol * cellWidth;
            const baseTop = gridRow * cellHeight;
            const offsetLeft = getRandomInt(-cellWidth * 0.6, cellWidth * 0.6);
            const offsetTop = getRandomInt(-cellHeight * 0.6, cellHeight * 0.6);
            
            const left = Math.max(10, Math.min(headerWidth - size - 10, basLeft + offsetLeft));
            const top = Math.max(10, Math.min(headerHeight - size - 10, baseTop + offsetTop));
            
            const delay = index * 50; // Stagger animation
            
            photoElement.style.width = `${size}px`;
            photoElement.style.height = `${size}px`;
            photoElement.style.top = `${top}px`;
            photoElement.style.left = `${left}px`;
            photoElement.style.transform = `rotate(${rotation}deg)`;
            photoElement.style.animationDelay = `${delay}ms`;
            
            const img = document.createElement('img');
            img.src = `assets/img/optimized-small/${photo}`;
            img.alt = 'Background photo';
            img.loading = 'lazy';
            
            photoElement.appendChild(img);
            container.appendChild(photoElement);
        });

        // Add parallax effect on scroll if enabled
        if (config.parallaxEffect) {
            let ticking = false;
            
            window.addEventListener('scroll', function() {
                if (!ticking) {
                    window.requestAnimationFrame(function() {
                        const scrolled = window.pageYOffset;
                        const photos = document.querySelectorAll('.scattered-photo');
                        
                        photos.forEach((photo, index) => {
                            const speed = 0.3 + (index % 3) * 0.1;
                            const translateY = scrolled * speed;
                            const currentRotation = photo.style.transform.match(/rotate\((.+?)deg\)/)[1];
                            photo.style.transform = `translateY(${translateY}px) rotate(${currentRotation}deg)`;
                        });
                        
                        ticking = false;
                    });
                    
                    ticking = true;
                }
            });
        }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createScatteredPhotos);
    } else {
        createScatteredPhotos();
    }

    /*
    // Refresh on window resize (debounced)
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(createScatteredPhotos, 250);
    });
    */

})();
